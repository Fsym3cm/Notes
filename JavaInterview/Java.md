# Java面试题

#### 1，什么是Java虚拟机？为什么Java被称作是“与平台无关的编程语言”？

答：Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。

​       Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。

​       Java源程序先经过Javac编译器编译成二进制的.class字节码文件（Java的跨平台指的就是.class字节码文件的跨平台，.class字节码文件是与平台无关的），.class文件再运行在Jvm上，Java解释器（Jvm的一部分）会将其解释成对应平台的机器码执行，所以Java的跨平台就是在在不同的平台上安装不同的Jvm,而在不同平台上生成的.class文件都是一样的，.class文件再由对应平台的Jvm解释成对应平台的机器码执行。

#### 2，JDK和JRE的区别是什么？

答：JDK是Java开发工具包，是程序员使用java语言编写Java程序所需的开发工具包，是提供给程序员使用的。JDK包含了JRE，同时还包含了编译Java源码的编译器Javac，还包含了很多Java程序调试和分析的工具：Jconsole，Jvisualvm等工具软件，还包含了Java程序编写所需的文档和Demo例子程序。

​        JRE是Java运行时环境，包含了Java虚拟机，Java基础类库。是使用Java语言编写的程序运行所需要的软件环境，是提供给想运行Java程序的用户使用。

#### 3，“static”关键字是什么意思？Java中是否可以覆盖一个private或者static方法。

答：“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例额变量的情况下被访问。

​        Java中的static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而Static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。

​        Java中也不可以覆盖private的方法，因为private修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到private变量或方法的，当然也不能覆盖。

#### 4，是否可以在static环境中访问非static变量。

答：static变量在Java中是属于类的，它在所有的实例中的值都是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。

#### 5，Java支持的数据类型有哪些？什么是自动拆装箱？

答：Java语言支持的8种基本数据类型是：byte，short，int，long，float，double，boolean，char。

​		自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化为Double等等，反之就是自动拆箱。

​		Java支持的数据类型包括两种：一种是基本数据类型，包含byte,short,int,long,double,float,boolean,char;另一种是引用类型：如String等，其实是对象的引用，JVM中的虚拟栈中存的是对象的地址，创建的对象实质在堆中，通过地址来找到堆中的对象的过程，即为引用类型。自动装箱就是Java编译器在基本数据类型和对应的对象包装类型间的转化，即int转化为Integer，自动拆箱就是Integer调用其方法将其转化为int的过程。

#### 6，Java中的方法覆盖和方法重载是什么意思？

答：Java中方法覆盖是指子类重新定义了父类的方法，它必须有相同的方法名，参数列表和返回类型，覆盖者可能不会限制它所覆盖的方法的访问。

​        Java中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。

#### 7，Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？

答：当新对象被创建的时候，构造方法会被调用。每一个类都有构造方法。在程序员没有给类提供构造方法的情况下，Java编译器会为这个类创建一个默认的构造方法。

​		Java中构造方法重载和方法重载很相似。一个类可以创建多个构造方法。每个构造方法必须有它唯一的参数列表。

​		Java中不支持像c++中那样的复制构造方法，这个不同点是因为如果你不自己写构造方法的情况下，Java不会创建默认的复制构造方法。

#### 8，Java中支持多继承么？

答：Java中类不支持多继承，只支持单继承（即一个类只有一个父类）。但是Java中的接口支持多继承，即一个子接口可以有很多父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）。

#### 9，接口和抽象类的区别是什么？

Java提供和支持创建抽象类和接口。他们的实现有共同特点，不同点在于：

1. 接口中所有的方法隐含都是抽象的。而抽象类则可以同时包含抽象和非抽象方法。
2. 类可以实现多个接口，但是只能继承一个抽象类。
3. 类可以不实现抽象类和接口声明的所有方法，但是类必须声明成抽象的。
4. 抽象类可以在不提供接口方法实现的情况下实现接口。
5. Java借口中声明的变量默认是final的。抽象类可以包含非final的变量。
6. Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public的。
7. 接口是绝对抽象的，不可以被实例化，抽象类也不可以被实例化。

从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。

#### 10，什么是值传递和引用传递？

答：值传递是对于基本型变量而言的，传递的是该变量的一个副本，改变副本不影响原变量。

​		引用传递一般是对于对象型变量而言，传递的是该对象地址的一个副本，而不是源对象本身。

​		一般认为Java内的基础类型数据传递都是值传递，Java中实例对象的传递是引用传递。

#### 11，进程和线程的区别是什么？

答：进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。

线程与进程的区别归纳：

1. 地址空间和其他资源：进程间相互独立，同一进程的各线程间共享。某线程内的线程在其他进程不可见。
2. 通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步或互斥手段的辅助，以保证数据的一致性。
3. 调度和切换：线程上下文切换比进程上下文切换要快的多。
4. 在多线程OS中，进程不是一个可执行实体。

#### 12，创建线程有几种不同的方式？你喜欢哪一种？为什么？

答：有四种方式可以用来创建线程：

1. 继承Thread类。

2. 实现Runnable接口。

3. 应用程序可以使用Executor框架来创建线程池

4. 实现Callable接口。

   使用Runnable接口更为欢迎，因为这不需要继承Thread类。在应用设计中以及继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。同时，线程池也是十分高效和容易实现和使用。

#### 13，概括的解释下线程的几种可用状态。

答：

1. 新建(new)：新创建一个线程对象。
2. 可运行(runnable)：线程对象创建后，其他线程(比如main线程)调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待线程调度选中获得cpu使用权。
3. 运行(running)：可运行状态(runnable)的线程获得了cpu时间片(timeslice)，执行程序代码。
4. 阻塞(block)：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，展示停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice转到运行(runnable)状态。阻塞的情况分三种：
   1. 等待阻塞：运行的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。
   2. 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的的线程占用，则JVM会把该线程放入锁池(lock pool)中。
   3. 其他阻塞：运行的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程职位阻塞状态。当sleep()状态超时，join()等待线程终止或者超时，或者I/O处理完毕时，线程重新转入可运行状态。
5. 死亡(dead)：线程run()，main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再复生。

![](Photo\ThreadState.png)

#### 14，同步方法和同步代码块的区别是什么？

答：同步方法默认用this或者当前类class对象作为锁；

​        同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法；

​        同步方法使用关键字synchronized修饰方法，而同步代码块主要是修饰需要进行同步的代码，用synchronized(object) {代码内容}进行修饰。

#### 15，在监视器(Monitor)内部，是如何做线程同步的？程序应该做到那种级别的同步？

答：监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。

#### 16，什么是死锁(deadlock)?

答：死锁是指多个进程因竞争资源而造成的一种僵局(互相等待)，若无外力作用，这些进程都将无法向前推进。死锁产生的4个必要条件：

1. 互斥条件：进程要求对所分配的资源(如打印机)进行排他性控制，即在一段时间内某资源仅为一个进程占有。此时若有其他进程请求该资源，则请求进程只能等待。
2. 不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放(只能是主动释放)。
3. 请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。
4. 循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被链中下一个进程所请求。

#### 17，如何确保N个线程可以访问N个资源同时又不导致死锁？

答：使用多线程的时候，一种非常简单的避免死锁的方式是：指定获取锁的顺序，并强制线程安装指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁。

#### 18，Java集合类框架的基本接口有哪些？

答：集合类接口指定了一组叫元素的对象。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和排序。有的集合类允许重复键，有些不允许。

Java集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java类里面最基本的接口有：

1. Collection：代表一组对象，每一个对象都是它的子元素。
2. Set：不包含重复元素的Collection.
3. List：有顺序的collection，并且可以包含重复元素。
4. Map：可以把键(key)映射到值(value)的对象，键不能重复。

![](Photo\Assemble.png)

#### 19，为什么集合类没有实现Colneable和Serializable接口？

答：克隆(cloning)或者是序列化(serializable)的语义和含义是跟具体的实现类相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是被序列化。

**20，什么是迭代器？**

答：Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的迭代方法。迭代器可以在迭代的过程中删除底层集合的元素，但是不可以直接调用集合的remove(Object obj)删除，可以通过迭代器的remove()方法删除。

#### 21，Iterator和ListIterator的区别是什么？

答：Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。

​		Iterator对集合只能是向前遍历，ListIterator既可以向前也可以向后。

​		ListIterator实现了Iterat接口，并包括其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。

#### 22，快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？

答：**快速失败：**在用迭代器遍历一个集合对象时，如果遍历过程中对集合的结构进行了修改(增加，删除)，则会抛出Concurrent Modification Exception。

​		原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个modCount遍历。集合再被遍历期间如果结构发生变化，就会改变modCount的值。每当迭代器使用hashNext().next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，使得话就返回遍历，否则抛出异常，终止遍历。

​		注意：这里异常的抛出条件是检测到modCount！= expectedmodCount 这个条件。如果集合发生变化是修改的值刚好又设置为expectedmodCount 值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检查并发修改的bug。

​		场景：Java.util包下的集合类都是快速失败的，不能再多线程

下发生并发修改(迭代过程中被修改)。

​         **安全失败：**采用安全失败机制的集合容器，在遍历是不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。

​		原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。

​		缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。

​		场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。

23，Java中HashMap的工作原理是什么？

答：Java中的HashMap是以键值对(key-value)的形式存储元素的。HashMap需要一个hash函数，它使用hashCode()和equals()

方法来向集合/从集合添加和检索元素。当调用put()方法的时候，HashMap会计算key的hash值，然后把键值对存储在集合中合适的索引上。如果key以经存在，value会被 更新成新值。HashMap的一些重要的特性是它的容量(capacity)，负载因子(load factor)和扩容极限(threshold resizing)。    

​		详解：hashmap是一个key-value键值对的数据结构，从结构上来讲在jdk1.8之前是用数组加链表的方式实现，jdk1.8加了红黑树，hashmap数组的默认初始长度是16，hashmap数组只允许一个key为null，允许多个value为null
​		hashmap的内部实现，hashmap是使用数组+链表+红黑树的形式实现的，其中数组是一个一个Node[]数组，我们叫他hash桶数组，它上面存放的是key-value键值对的节点。HashMap是用hash表来存储的，在hashmap里为解决hash冲突，使用链地址法，简单来说就是数组加链表的形式来解决，当数据被hash后，得到数组下标，把数据放在对应下表的链表中。
 然后再说一下hashmap的方法实现
 		put方法，put方法的第一步，就是计算出要put元素在hash桶数组中的索引位置，得到索引位置，第二步是去put元素key的hashcode值，高位运算，取模运算，高位运算就是用第一步得到的值h，用h的高16位和低16位进行异或操作，第三步为了使hash桶数组元素分布更均匀，采用取模运算，取模运算就是用第二步得到的值和hash桶数组长度-1的值取与。这样得到的结果和传统取模运算结果一致，而且效率比取模运算高
 		jdk1.8中put方法的具体步骤，先判断hashmap是否为空，为空的话扩容，不为空计算出key的hash值i，然后看table[i]是否为空，为空就直接插入，不为空判断当前位置的key和table[i]是否相同，相同就覆盖，不相同就查看table[i]是否是红黑树节点，如果是的话就用红黑树直接插入键值对，如果不是开始遍历链表插入，如果遇到重复值就覆盖，否则直接插入，如果链表长度大于8，转为红黑树结构，执行完成后看size是否大于阈值threshold，大于就扩容，否则直接结束
 		get方法就是计算出要获取元素的hash值，去对应位置取即可。
 		扩容机制，hashmap的扩容中主要进行两部，第一步把数组长度变为原来的两倍，第二步把旧数组的元素重新计算hash插入到新数组中，在jdk1.8时，不用重新计算hash，只用看看原来的hash值新增的一位是零还是1，如果是1这个元素在新数组中的位置，是原数组的位置加原数组长度，如果是零就插入到原数组中。扩容过程第二步一个非常重要的方法是transfer方法，采用头插法，把旧数组的元素插入到新数组中。
 		3.hashmap大小为什么是2的幂次方
 在计算插入元素在hash桶数组的索引时第三步，为了使元素分布的更加均匀，用取模操作，但是传统取模操作效率低，然后优化成h&(length-1)，设置成2幂次方，是因为2的幂次方-1后的值每一位上都是1，然后与第二步计算出的h值与的时候，最终的结果只和key的hashcode值本身有关，这样不会造成空间浪费并且分布均匀。如果length不为2的幂，比如15。那么length-1的2进制就会变成1110。在h为随机数的情况下，和1110做&操作。尾数永远为0。那么0001、1001、1101等尾数为1的位置就永远不可能被entry占用。这样会造成浪费，不随机等问题。

#### 24，hashCode()和equals()方法的重要性体现在什么地方？

答：Java中的HashMap使用hashCode()和equals()方法在确定键值对的索引，但根据键获取值的时候也会用到这两个方法。如果没有正确的实现这两个方法，两个不同的键可能会有相同的hash值，因此肯会被集合认为是相等的。而且这两个方法也用来发现重复元素。索引这两个方法的实现对HashMap的精确性和正确性是至关重要的。

#### 25，HashMap和Hashtable有什么区别？

答：HashMap和Hashtable都实现了Map接口，其不同点在于：

1. HashMap是非线程安全的，HashTable是线程安全的。 
2. HashMap的键和值都允许有null值存在，而HashTable则不行。 
3. 因为线程安全的问题，HashMap效率比HashTable的要高。 
4. Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。	

​        一般现在**不建议用HashTable**,  ①是HashTable是遗留类，内部实现很多没优化和冗余。②即使在**多线程**环境下，现在也有同步的**ConcurrentHashMap**替代，没有必要因为是多线程而用HashTable。