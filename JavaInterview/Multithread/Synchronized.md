# Synchronized

![](../Photo/Synchronized.png)

### synchronized关键字最主要的三种使用方式的总结

- **修饰实例方法：作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁**。
- **修饰静态方法：作用于当前类对象加锁，进入同步代码前获得当前类对象的锁**。也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员(static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份，所以对该类的所有对象都加了锁)。所以如果一个线程A调用一个实例对象的非静态synchrinized方法，而线程B需要调用这个实例对象所属类的静态synchronized方法，是允许的，不会发生互斥现象，**因为访问静态synchronized方法占用的锁是当前类的锁，而访问非静态synchronized方法占用的锁是当前实例对象锁**。
- **修饰代码块：指定加锁对象，对给定对象加锁，进入同步代码块前要获得给定对象的锁**。和synchronized方法一样，synchronized(this)代码块也是锁定当前对象的。sychronized关键字加到static静态方法和synchronized(class)代码块上都是给Class类上锁。这里再提一下：synchronized关键字加到非静态方法上是给对象实例上锁。另外需要注意的是：尽量不要使用synchronized(String a)因为JVM中，字符串常量池具有缓冲功能。

### synchronized关键字的具体使用

双重检验锁实现对象单例(线程安全)

```java
class Singleton {
    private static volatile Singleton singleton;

    private Singleton(){

    }

    public static Singleton getSingleton(){
        //先判断对象是否已经实例化，没有实例化再进入加锁代码块
        if (singleton == null){
            //类对象加锁
            synchronized (Singleton.class){
                if (singleton == null)
                    singleton = new Singleton();
            }
        }
        return singleton;
    }

    public static void main(String[] args) {
        System.out.println(getSingleton() == getSingleton());
    }
}
```

另外需要注意的是singleton应采用volatile修饰。

`singleton = new Singleton();`这段代码其实是分为三步执行：

1. 为singleton分配内存空间。
2. 初始化singleton。
3. 将singleton指向分配的内存地址。

但是由于JVM具有指令重排的特性，执行顺序有可能变成1->3->2。指令重排在单线程环境不会出现问题，但是在多线程环境下会导致一个线程获得还没初始化的实例。例如，线程T1执行了1和3，此时T2调用getSingleton()后发现singleton不为空，因此返回singleton，但此时singleton还未被初始化。

使用volatile可以禁止JVM的指令重排，保证在多线程下也能正常运行。

### synchronized关键字底层原理属于JVM层面。

1. **synchronized同步语句块的情况**

   ```java
   public class SynchronizedDemo {
   	public void method() {
   		synchronized (this) {
   			System.out.println("synchronized 代码块");
   		}
   	}
   }
   ```

   **synchronized同步语句的实现使用的是monitorenter和monitorexit指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则知名同步代码块的结束位置**。当执行monitorenter指令时，线程试图获取锁也就是获取monitor(monitor对象存在于每个Java对象的对象头中，synchronized锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因)的持有权，当计数器为0时则可以成功获取，获取后将锁的计数器设为1也就是加1.相应的在执行monitorexit指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那么当前线程就要阻塞等待，直到锁被另一个线程释放为止。

2. **synchronized修饰方法的情况**

   ```
   public class SynchronizedDemo2 {
   	public synchronized void method() {
   		System.out.println("synchronized 方法");
   	}
   }
   ```

   synchronized修饰方法并没有monitorenter指令和monitorexit指令，取而代之的是ACC_SYNCHRONIZED标识，该标识指明了该方法是一个同步方法，JVM通过该ACC_SYNCHRONIZED访问标识来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。

   在Java早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁(monitor)是依赖于底层的操作系统的Mutex Lock来实现的，Java的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换为内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期synchronized效率低的原因。庆幸的是在Java 6之后Java官方对从JVM层面对synchronized较大优化，所以现在的synchronized锁效率优化得很不错。JDK1.6对锁的实现引入了大量的优化，比如自旋锁，适用性自旋锁，锁消除，锁粗化，偏向锁，轻量级锁等技术来减少锁操作的开销。

### JDK1.6之后的底层优化

说主要存在四种状态，依次是：无锁状态，偏向锁转态，轻量级锁状态，重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。

1. #### 偏向锁

   **引入偏向锁的目的是和引入轻量级锁的目的很像，他们都是为了没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。但是不同的是：轻量级锁在无竞争的情况下使用CAS操作去代替使用互斥量。而偏向锁在无竞争的情况下会把整个同步都消除掉。**

   偏向锁的“偏”就是偏心的偏，他的意思是会偏向于第一个获得它的线程，如果在接下来执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步。

   但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样的场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。

2. #### 轻量级锁

   倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，他还会尝试一种轻量级锁的优化手段(1.6后加入的)。**轻量级锁不是为了代替重量级锁，他的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，因为使用轻量级锁时，不需要申请互斥量。另外，轻量级锁的加锁和解锁都用到了CAS操作**。

   **轻量级锁能够提升程序同步性能的依据是“对于绝大部分锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据，如果没有竞争，轻量级锁使用CAS操作避免了使用互斥操作的开销。但是如果存在锁竞争，除了互斥量开销外，还会发生额外的CAS操作，因此再有锁竞争的情况下，轻量级锁比传统的重量级锁更慢。如果锁竞争激烈，那么轻量级锁将很快膨胀为重量级锁。**

3. #### 自旋锁和自适应自旋锁

   轻量级锁失败后，虚拟机为了避免线程真是地在操作系统层面挂起，还会进行一项自旋锁的优化手段。

   互斥同步对性能最大的影响就是阻塞的实现，因为挂起线程/恢复线程的操作都需要转入内核态中完成(用户态转换到内核态会耗费时间)。

   **一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的。**所以，虚拟机的开发团队就这样去考虑：“我们能不能让后面来到请求获取锁的线程等待一会而不被挂起？看看持有锁的线程是否很快就会释放锁”。**为了让一个线程等待，我们只需要让一个线程执行一个忙循环(自旋)，这些技术就叫做自旋。**

   自旋锁在JDK1.6之前其实就已经引入了，默认关闭的。JDK1.6及以后，改为默认开启，需要注意的是：自旋锁并不能完全替代阻塞，因为它还是要占用处理器时间的。如果锁被占用的时间短，那么效果就很好，反之，相反。自旋等待的时间必须有限度。如果自旋超过了限定次数仍然没有获得锁就应该挂起线程。自旋次数默认为10次。

   **在JDK1.6中引入了自适应的自旋锁。自适应的自旋锁带来的改进就是：自旋时间不再固定了，而是和前一次同一个锁上的自旋时间以及锁的拥有者状态来决定。**

4. #### 锁消除

   锁消除指的是虚拟机即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。锁消除可以节省毫无意义请求锁的时间。

5. #### 锁粗化

   原则上，我们在编写代码的时候，总是推荐将同步块的范围限制的尽量小，直到在共享数据的实际作用域才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那么等待线程也能尽快拿到锁。

   大部分情况下，上面的原则都是没有问题的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，那么会带来很多不必要的性能消耗。

### Synchronized和ReenTrantLock的对比

1. #### 两者都是可重入锁

   “可重入锁”：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，等到锁的计数器下降为0时才能释放锁。

2. #### synchronized依赖于JVM而ReenTrantLock依赖于API

   synch是依赖于JVM实现的，原理在前面，ReenTrantLock是在JDK层面实现的(也就是API层面，需要lock()和unlock()方法配合try/finally语句块来完成)。

3. #### ReenTrantLock比synchronized增加了一些高级功能

   - **等待可中断：提供了一种能够中断等待锁的线程机制。**通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待改为处理其他事情。

   - **可实现公平锁**：**ReenTrantLock可以指定是公平锁还是非公平锁，而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁**。 ReenTrantLock默认情况是非公平的，可以通过 ReenTrantLock类的`ReentrantLock(boolean fair)`构造方法来制定是否是公平的。

   - **可实现选择性通知(所可以绑定多个条件)**：synchronized关键字与wait()和notify/notifyAll()方法相结合可以实现等待/通知机制，ReenTrantLock在JDK1.5后借助Condition接口余额newCondition()方法也可以实现。它可以实现多路通知功能，也就是在一个Lock对象中可以创建多个Condition实例(即对象监视器)，**线程对象可以注册在指定的Condition中，从而可以已选择性的进行线程通知，在调度线程上更加灵活。在使用notify/notifyAll()方法进行通知时，被通知的线程是由JVM选择的，用ReenTrantLock类结合Condition实例可以实现”选择性通知“**。

   - **性能标准**

     在JDK1.6之前，synchronized的性能比ReenTrantLock 差很多，在之后，其性能基本持平。优化后的synchronized和ReenTrantLock 一样，在很多地方都是用到CAS操作。